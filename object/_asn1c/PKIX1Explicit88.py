#
# This file was generated by the Objective Systems ASN1C Compiler
# (https://obj-sys.com).  Version: 7.8.0, Date: 12-Mar-2024.
#
# Command:  asn1c PKIX1Explicit88.asn -der -python
#
import osyspyrt.asn1error as exc
import osyspyrt.asn1univtype as univ
import osyspyrt.asn1ber as ber

id_pkix = [1, 3, 6, 1, 5, 5, 7]
id_pe = [1, 3, 6, 1, 5, 5, 7, 1]
id_qt = [1, 3, 6, 1, 5, 5, 7, 2]
id_kp = [1, 3, 6, 1, 5, 5, 7, 3]
id_ad = [1, 3, 6, 1, 5, 5, 7, 48]
id_qt_cps = [1, 3, 6, 1, 5, 5, 7, 2, 1]
id_qt_unotice = [1, 3, 6, 1, 5, 5, 7, 2, 2]
id_ad_ocsp = [1, 3, 6, 1, 5, 5, 7, 48, 1]
id_ad_caIssuers = [1, 3, 6, 1, 5, 5, 7, 48, 2]
id_ad_timeStamping = [1, 3, 6, 1, 5, 5, 7, 48, 3]
id_ad_caRepository = [1, 3, 6, 1, 5, 5, 7, 48, 5]
id_at = [2, 5, 4]
id_at_name = [2, 5, 4, 41]
id_at_surname = [2, 5, 4, 4]
id_at_givenName = [2, 5, 4, 42]
id_at_initials = [2, 5, 4, 43]
id_at_generationQualifier = [2, 5, 4, 44]
id_at_commonName = [2, 5, 4, 3]
id_at_localityName = [2, 5, 4, 7]
id_at_stateOrProvinceName = [2, 5, 4, 8]
id_at_organizationName = [2, 5, 4, 10]
id_at_organizationalUnitName = [2, 5, 4, 11]
id_at_title = [2, 5, 4, 12]
id_at_dnQualifier = [2, 5, 4, 46]
id_at_countryName = [2, 5, 4, 6]
id_at_serialNumber = [2, 5, 4, 5]
id_at_pseudonym = [2, 5, 4, 65]
id_domainComponent = [0, 9, 2342, 19200300, 100, 1, 25]
pkcs_9 = [1, 2, 840, 113549, 1, 9]
id_emailAddress = [1, 2, 840, 113549, 1, 9, 1]
common_name = 1
teletex_common_name = 2
teletex_organization_name = 3
teletex_personal_name = 4
teletex_organizational_unit_names = 5
pds_name = 7
physical_delivery_country_name = 8
postal_code = 9
physical_delivery_office_name = 10
physical_delivery_office_number = 11
extension_OR_address_components = 12
physical_delivery_personal_name = 13
physical_delivery_organization_name = 14
extension_physical_delivery_address_components = 15
unformatted_postal_address = 16
street_address = 17
post_office_box_address = 18
poste_restante_address = 19
unique_postal_name = 20
local_postal_attributes = 21
extended_network_address = 22
terminal_type = 23
teletex_domain_defined_attributes = 6
ub_name = 32768
ub_common_name = 64
ub_locality_name = 128
ub_state_name = 128
ub_organization_name = 64
ub_organizational_unit_name = 64
ub_title = 64
ub_serial_number = 64
ub_match = 128
ub_emailaddress_length = 128
ub_common_name_length = 64
ub_country_name_alpha_length = 2
ub_country_name_numeric_length = 3
ub_domain_defined_attributes = 4
ub_domain_defined_attribute_type_length = 8
ub_domain_defined_attribute_value_length = 128
ub_domain_name_length = 16
ub_extension_attributes = 256
ub_e163_4_number_length = 15
ub_e163_4_sub_address_length = 40
ub_generation_qualifier_length = 3
ub_given_name_length = 16
ub_initials_length = 5
ub_integer_options = 256
ub_numeric_user_id_length = 32
ub_organization_name_length = 64
ub_organizational_unit_name_length = 32
ub_organizational_units = 4
ub_pds_name_length = 16
ub_pds_parameter_length = 30
ub_pds_physical_address_lines = 6
ub_postal_code_length = 16
ub_pseudonym = 128
ub_surname_length = 40
ub_terminal_id_length = 24
ub_unformatted_address_length = 180
ub_x121_address_length = 16


class X520countryName:
    """Class definition for ASN.1 type:

    PrintableString (SIZE (2))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(19, explicit, impllen)
        if not len(value) == 2:
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not len(value) == 2:
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 19, tagbytes)


class X520SerialNumber:
    """Class definition for ASN.1 type:

    PrintableString (SIZE (1..ub-serial-number))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(19, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 19, tagbytes)


class EmailAddress:
    """Class definition for ASN.1 type:

    IA5String (SIZE (1..ub-emailaddress-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(22, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 128):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 128):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 22, tagbytes)


class AttributeTypeAndValue:
    """Class definition for ASN.1 type:

    SEQUENCE {
        type AttributeType,
        value AttributeValue
    }
    Attributes
    ----------
    type : AttributeType
    value : AttributeValue
    """
    __slots__ = ["type", "value"]

    def __init__(self):
        self.type = None
        self.value = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("AttributeTypeAndValue tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode type

        elemlen = decctxt.match_elem_tag(bytearray([0x06]), 0)
        if elemlen is not None:
            self.type = decbuf.decode_oid()
        else:
            raise exc.Asn1MissingRequiredError("type")

        # decode value

        if not decctxt.expired():
            self.value = decbuf.decode_opentype()
        else:
            raise exc.Asn1MissingRequiredError("value")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode value

        if self.value is not None:
            len1 = encbuf.encode_opentype(self.value)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("value")

        # encode type

        if self.type is not None:
            len1 = encbuf.encode_oid(self.type)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("type")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class RelativeDistinguishedName:
    """Class definition for ASN.1 type:

    SET (SIZE (1..MAX)) OF AttributeTypeAndValue
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x31])):
                raise exc.Asn1TagError("RelativeDistinguishedName tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = AttributeTypeAndValue()
            value.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        saved_encbuf = encbuf
        encbuf = ber.Asn1BerEncodeBuffer()
        encoded_elems = []
        for value in reversed(value_list):
            len1 = value.ber_encode(encbuf)
            len0 += len1
            encoded_elems.append(encbuf.buffer())
            encbuf = ber.Asn1BerEncodeBuffer()

        encbuf = saved_encbuf
        encoded_elems.sort()

        for encbytes in reversed(encoded_elems):
            encbuf.encode_bytes(encbytes)

        if tagbytes is None:
            tagbytes = bytearray([0x31])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class RDNSequence:
    """Class definition for ASN.1 type:

    SEQUENCE OF RelativeDistinguishedName
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("RDNSequence tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = RelativeDistinguishedName.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        for value in reversed(value_list):
            len1 = RelativeDistinguishedName.ber_encode(value, encbuf)
            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class Version:
    """Class definition for ASN.1 type:

    INTEGER { v1(0), v2(1), v3(2) }
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        enum_mapping = {
            0: "v1",
            1: "v2",
            2: "v3"
        }
        enumval = decbuf.decode_integer(explicit, impllen)
        value = enum_mapping.get(enumval, None)
        if value is None:
            value = enumval
        else:
            value = univ.NamedInt(enumval, value)

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        enum_mapping = {
            "v1": 0,
            "v2": 1,
            "v3": 2
        }
        if type(value) == str:
            enumval = enum_mapping.get(value, None)
            if enumval is not None:
                return encbuf.encode_integer(enumval, tagbytes)
            else:
                raise exc.Asn1InvalidEnumError(value)
        else:
            return encbuf.encode_integer(value, tagbytes)


class X121Address:
    """Class definition for ASN.1 type:

    NumericString (SIZE (1..ub-x121-address-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(18, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 16):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 16):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 18, tagbytes)


class TerminalIdentifier:
    """Class definition for ASN.1 type:

    PrintableString (SIZE (1..ub-terminal-id-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(19, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 24):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 24):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 19, tagbytes)


class OrganizationName:
    """Class definition for ASN.1 type:

    PrintableString (SIZE (1..ub-organization-name-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(19, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 19, tagbytes)


class NumericUserIdentifier:
    """Class definition for ASN.1 type:

    NumericString (SIZE (1..ub-numeric-user-id-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(18, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 32):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 32):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 18, tagbytes)


class OrganizationalUnitName:
    """Class definition for ASN.1 type:

    PrintableString (SIZE (1..ub-organizational-unit-name-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(19, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 32):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 32):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 19, tagbytes)


class CommonName:
    """Class definition for ASN.1 type:

    PrintableString (SIZE (1..ub-common-name-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(19, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 19, tagbytes)


class TeletexCommonName:
    """Class definition for ASN.1 type:

    T61String (SIZE (1..ub-common-name-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(20, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 20, tagbytes)


class TeletexOrganizationName:
    """Class definition for ASN.1 type:

    T61String (SIZE (1..ub-organization-name-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(20, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 64):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 20, tagbytes)


class TeletexOrganizationalUnitName:
    """Class definition for ASN.1 type:

    T61String (SIZE (1..ub-organizational-unit-name-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(20, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 32):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 32):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 20, tagbytes)


class PDSName:
    """Class definition for ASN.1 type:

    PrintableString (SIZE (1..ub-pds-name-length))
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        value = decbuf.decode_charstr(19, explicit, impllen)
        if not (len(value) >= 1 and len(value) <= 16):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (len(value) >= 1 and len(value) <= 16):
            raise exc.Asn1ConsVioError("len(value)", len(value))

        return encbuf.encode_charstr(value, 19, tagbytes)


class PDSParameter:
    """Class definition for ASN.1 type:

    SET {
        printable-string PrintableString (SIZE (1..ub-pds-parameter-length)) OPTIONAL,
        teletex-string T61String (SIZE (1..ub-pds-parameter-length)) OPTIONAL
    }
    Attributes
    ----------
    printable_string : charstr
    teletex_string : charstr
    """
    __slots__ = ["printable_string", "teletex_string"]

    def __init__(self):
        self.printable_string = None
        self.teletex_string = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x31])):
                raise exc.Asn1TagError("PDSParameter tag match failed")

            impllen = decbuf.decode_length()

        # decode SET

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            # decode printable_string

            elemlen = decctxt.match_set_elem_tag(bytearray([0x13]), 0)
            if elemlen is not None:
                self.printable_string = decbuf.decode_charstr(19)
                if not (len(self.printable_string) >= 1 and len(self.printable_string)
                     <= 30):
                    raise exc.Asn1ConsVioError("len(self.printable_string)", len(self.printable_string))

                continue

            # decode teletex_string

            elemlen = decctxt.match_set_elem_tag(bytearray([0x14]), 0)
            if elemlen is not None:
                self.teletex_string = decbuf.decode_charstr(20)
                if not (len(self.teletex_string) >= 1 and len(self.teletex_string)
                     <= 30):
                    raise exc.Asn1ConsVioError("len(self.teletex_string)", len(self.teletex_string))

                continue

            raise exc.Asn1NotInSetError(decbuf.decode_tag())

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode teletex_string

        if self.teletex_string is not None:
            if not (len(self.teletex_string) >= 1 and len(self.teletex_string) <= 30):
                raise exc.Asn1ConsVioError("len(self.teletex_string)", len(self.teletex_string))

            len1 = encbuf.encode_charstr(self.teletex_string, 20)

            len0 += len1

        # encode printable_string

        if self.printable_string is not None:
            if not (len(self.printable_string) >= 1 and len(self.printable_string)
                 <= 30):
                raise exc.Asn1ConsVioError("len(self.printable_string)", len(self.printable_string))

            len1 = encbuf.encode_charstr(self.printable_string, 19)

            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x31])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class TerminalType:
    """Class definition for ASN.1 type:

    INTEGER { telex(3), teletex(4), g3-facsimile(5), g4-facsimile(6), ia5-terminal(7), videotex(8) } (0..ub-integer-options)
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        enum_mapping = {
            3: "telex",
            4: "teletex",
            5: "g3-facsimile",
            6: "g4-facsimile",
            7: "ia5-terminal",
            8: "videotex"
        }
        enumval = decbuf.decode_integer(explicit, impllen)
        value = enum_mapping.get(enumval, None)
        if value is None:
            value = enumval
        else:
            value = univ.NamedInt(enumval, value)

        if not (value >= 0 and value <= 256):
            raise exc.Asn1ConsVioError("value", value)

        return value

    @staticmethod
    def ber_encode(value, encbuf, tagbytes=None):
        if not (value >= 0 and value <= 256):
            raise exc.Asn1ConsVioError("value", value)

        enum_mapping = {
            "telex": 3,
            "teletex": 4,
            "g3-facsimile": 5,
            "g4-facsimile": 6,
            "ia5-terminal": 7,
            "videotex": 8
        }
        if type(value) == str:
            enumval = enum_mapping.get(value, None)
            if enumval is not None:
                return encbuf.encode_integer(enumval, tagbytes)
            else:
                raise exc.Asn1InvalidEnumError(value)
        else:
            return encbuf.encode_integer(value, tagbytes)


class Attribute:
    """Class definition for ASN.1 type:

    SEQUENCE {
        type AttributeType,
        values SET OF AttributeValue
    }
    Attributes
    ----------
    type : AttributeType
    values : list
    """
    __slots__ = ["type", "values"]

    def __init__(self):
        self.type = None
        self.values = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("Attribute tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode type

        elemlen = decctxt.match_elem_tag(bytearray([0x06]), 0)
        if elemlen is not None:
            self.type = decbuf.decode_oid()
        else:
            raise exc.Asn1MissingRequiredError("type")

        # decode values

        elemlen = decctxt.match_elem_tag(bytearray([0x31]), 1)
        if elemlen is not None:
            # decode SEQUENCE OF / SET OF

            self.values = []
            decctxt1 = ber.Asn1BerDecodeContext(decbuf, elemlen)

            while not decctxt1.expired():
                value = decbuf.decode_opentype()
                self.values.append(value)

        else:
            raise exc.Asn1MissingRequiredError("values")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode values

        if self.values is not None:
            len1 = 0
            for value in reversed(self.values):
                len2 = encbuf.encode_opentype(value)
                len1 += len2

            tagbytes1 = bytearray([0x31])

            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(tagbytes1)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("values")

        # encode type

        if self.type is not None:
            len1 = encbuf.encode_oid(self.type)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("type")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class X520name(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-name)),
        printableString PrintableString (SIZE (1..ub-name)),
        teletexString T61String (SIZE (1..ub-name)),
        universalString UniversalString (SIZE (1..ub-name)),
        bmpString BMPString (SIZE (1..ub-name))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 32768):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString)
                 <= 32768):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 32768):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString)
                 <= 32768):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 32768):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 32768):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString)
                 <= 32768):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 32768):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString)
                 <= 32768):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 32768):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class X520CommonName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-common-name)),
        printableString PrintableString (SIZE (1..ub-common-name)),
        teletexString T61String (SIZE (1..ub-common-name)),
        universalString UniversalString (SIZE (1..ub-common-name)),
        bmpString BMPString (SIZE (1..ub-common-name))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class X520LocalityName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-locality-name)),
        printableString PrintableString (SIZE (1..ub-locality-name)),
        teletexString T61String (SIZE (1..ub-locality-name)),
        universalString UniversalString (SIZE (1..ub-locality-name)),
        bmpString BMPString (SIZE (1..ub-locality-name))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 128):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 128):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 128):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 128):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 128):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 128):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class X520StateOrProvinceName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-state-name)),
        printableString PrintableString (SIZE (1..ub-state-name)),
        teletexString T61String (SIZE (1..ub-state-name)),
        universalString UniversalString (SIZE (1..ub-state-name)),
        bmpString BMPString (SIZE (1..ub-state-name))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 128):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 128):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 128):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 128):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 128):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 128):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class X520OrganizationName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-organization-name)),
        printableString PrintableString (SIZE (1..ub-organization-name)),
        teletexString T61String (SIZE (1..ub-organization-name)),
        universalString UniversalString (SIZE (1..ub-organization-name)),
        bmpString BMPString (SIZE (1..ub-organization-name))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class X520OrganizationalUnitName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-organizational-unit-name)),
        printableString PrintableString (SIZE (1..ub-organizational-unit-name)),
        teletexString T61String (SIZE (1..ub-organizational-unit-name)),
        universalString UniversalString (SIZE (1..ub-organizational-unit-name)),
        bmpString BMPString (SIZE (1..ub-organizational-unit-name))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class X520Title(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-title)),
        printableString PrintableString (SIZE (1..ub-title)),
        teletexString T61String (SIZE (1..ub-title)),
        universalString UniversalString (SIZE (1..ub-title)),
        bmpString BMPString (SIZE (1..ub-title))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 64):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 64):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 64):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 64):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 64):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class X520Pseudonym(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..ub-pseudonym)),
        printableString PrintableString (SIZE (1..ub-pseudonym)),
        teletexString T61String (SIZE (1..ub-pseudonym)),
        universalString UniversalString (SIZE (1..ub-pseudonym)),
        bmpString BMPString (SIZE (1..ub-pseudonym))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 128):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 128):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 128):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not (len(self.utf8String) >= 1 and len(self.utf8String) <= 128):
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not (len(self.printableString) >= 1 and len(self.printableString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not (len(self.teletexString) >= 1 and len(self.teletexString) <= 128):
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not (len(self.universalString) >= 1 and len(self.universalString) <= 128
                ):
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not (len(self.bmpString) >= 1 and len(self.bmpString) <= 128):
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class Name(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
                  -- only one possibility for now
        rdnSequence RDNSequence
    }
    Attributes
    ----------
    rdnSequence : RDNSequence
    """
    __slots__ = ["rdnSequence"]

    def __init__(self):
        super().__init__()
        self.rdnSequence = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x30]), False):
            # decode rdnSequence
            self.rdnSequence = RDNSequence.ber_decode(decbuf)
        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "rdnSequence":
            len1 = RDNSequence.ber_encode(self.rdnSequence, encbuf)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class DirectoryString(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utf8String UTF8String (SIZE (1..MAX)),
        printableString PrintableString (SIZE (1..MAX)),
        teletexString T61String (SIZE (1..MAX)),
        universalString UniversalString (SIZE (1..MAX)),
        bmpString BMPString (SIZE (1..MAX))
    }
    Attributes
    ----------
    utf8String : charstr
    printableString : charstr
    teletexString : charstr
    universalString : universalstr
    bmpString : bmpstr
    """
    __slots__ = ["utf8String", "printableString", "teletexString", 
        "universalString", "bmpString"]

    def __init__(self):
        super().__init__()
        self.utf8String = None
        self.printableString = None
        self.teletexString = None
        self.universalString = None
        self.bmpString = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x0c]), False):
            # decode utf8String
            self.utf8String = decbuf.decode_charstr(12)
            if not len(self.utf8String) >= 1:
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printableString
            self.printableString = decbuf.decode_charstr(19)
            if not len(self.printableString) >= 1:
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

        elif decbuf.match_tag_bytes(bytearray([0x14]), False):
            # decode teletexString
            self.teletexString = decbuf.decode_charstr(20)
            if not len(self.teletexString) >= 1:
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

        elif decbuf.match_tag_bytes(bytearray([0x1c]), False):
            # decode universalString
            self.universalString = decbuf.decode_universalstr()
            if not len(self.universalString) >= 1:
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

        elif decbuf.match_tag_bytes(bytearray([0x1e]), False):
            # decode bmpString
            self.bmpString = decbuf.decode_bmpstr()
            if not len(self.bmpString) >= 1:
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utf8String":
            if not len(self.utf8String) >= 1:
                raise exc.Asn1ConsVioError("len(self.utf8String)", len(self.utf8String))

            len1 = encbuf.encode_charstr(self.utf8String, 12)
        elif attr == "printableString":
            if not len(self.printableString) >= 1:
                raise exc.Asn1ConsVioError("len(self.printableString)", len(self.printableString))

            len1 = encbuf.encode_charstr(self.printableString, 19)
        elif attr == "teletexString":
            if not len(self.teletexString) >= 1:
                raise exc.Asn1ConsVioError("len(self.teletexString)", len(self.teletexString))

            len1 = encbuf.encode_charstr(self.teletexString, 20)
        elif attr == "universalString":
            if not len(self.universalString) >= 1:
                raise exc.Asn1ConsVioError("len(self.universalString)", len(self.universalString))

            len1 = encbuf.encode_universalstr(self.universalString)
        elif attr == "bmpString":
            if not len(self.bmpString) >= 1:
                raise exc.Asn1ConsVioError("len(self.bmpString)", len(self.bmpString))

            len1 = encbuf.encode_bmpstr(self.bmpString)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class AlgorithmIdentifier:
    """Class definition for ASN.1 type:

    SEQUENCE {
        algorithm OBJECT IDENTIFIER,
        parameters ANY OPTIONAL
    }
    Attributes
    ----------
    algorithm : oid
    parameters : opentype
    """
    __slots__ = ["algorithm", "parameters"]

    def __init__(self):
        self.algorithm = None
        self.parameters = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("AlgorithmIdentifier tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode algorithm

        elemlen = decctxt.match_elem_tag(bytearray([0x06]), 0)
        if elemlen is not None:
            self.algorithm = decbuf.decode_oid()
        else:
            raise exc.Asn1MissingRequiredError("algorithm")

        # decode parameters

        if not decctxt.expired():
            self.parameters = decbuf.decode_opentype()

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode parameters

        if self.parameters is not None:
            len1 = encbuf.encode_opentype(self.parameters)

            len0 += len1

        # encode algorithm

        if self.algorithm is not None:
            len1 = encbuf.encode_oid(self.algorithm)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("algorithm")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class Time(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        utcTime UTCTime,
        generalTime GeneralizedTime
    }
    Attributes
    ----------
    utcTime : utctimestr
    generalTime : gentimestr
    """
    __slots__ = ["utcTime", "generalTime"]

    def __init__(self):
        super().__init__()
        self.utcTime = None
        self.generalTime = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x17]), False):
            # decode utcTime
            self.utcTime = decbuf.decode_utctimestr()
        elif decbuf.match_tag_bytes(bytearray([0x18]), False):
            # decode generalTime
            self.generalTime = decbuf.decode_gentimestr()
        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "utcTime":
            len1 = encbuf.encode_utctimestr(self.utcTime)
        elif attr == "generalTime":
            len1 = encbuf.encode_gentimestr(self.generalTime)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class Validity:
    """Class definition for ASN.1 type:

    SEQUENCE {
        notBefore Time,
        notAfter Time
    }
    Attributes
    ----------
    notBefore : Time
    notAfter : Time
    """
    __slots__ = ["notBefore", "notAfter"]

    def __init__(self):
        self.notBefore = None
        self.notAfter = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("Validity tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode notBefore

        elemlen = decctxt.match_elem_tag(bytearray([0x17]), 0)
        if elemlen is None:
            elemlen = decctxt.match_elem_tag(bytearray([0x18]), 0)
        if elemlen is not None:
            self.notBefore = Time()
            self.notBefore.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("notBefore")

        # decode notAfter

        elemlen = decctxt.match_elem_tag(bytearray([0x17]), 0)
        if elemlen is None:
            elemlen = decctxt.match_elem_tag(bytearray([0x18]), 0)
        if elemlen is not None:
            self.notAfter = Time()
            self.notAfter.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("notAfter")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode notAfter

        if self.notAfter is not None:
            len1 = self.notAfter.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("notAfter")

        # encode notBefore

        if self.notBefore is not None:
            len1 = self.notBefore.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("notBefore")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class SubjectPublicKeyInfo:
    """Class definition for ASN.1 type:

    SEQUENCE {
        algorithm AlgorithmIdentifier,
        subjectPublicKey BIT STRING 
    }
    Attributes
    ----------
    algorithm : AlgorithmIdentifier
    subjectPublicKey : bitstr
    """
    __slots__ = ["algorithm", "subjectPublicKey"]

    def __init__(self):
        self.algorithm = None
        self.subjectPublicKey = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("SubjectPublicKeyInfo tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode algorithm

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.algorithm = AlgorithmIdentifier()
            self.algorithm.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("algorithm")

        # decode subjectPublicKey

        elemlen = decctxt.match_elem_tag(bytearray([0x03]), 0)
        if elemlen is not None:
            self.subjectPublicKey = decbuf.decode_bitstr()
        else:
            raise exc.Asn1MissingRequiredError("subjectPublicKey")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode subjectPublicKey

        if self.subjectPublicKey is not None:
            len1 = encbuf.encode_bitstr(self.subjectPublicKey)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("subjectPublicKey")

        # encode algorithm

        if self.algorithm is not None:
            len1 = self.algorithm.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("algorithm")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class Extension:
    """Class definition for ASN.1 type:

    SEQUENCE {
        extnID OBJECT IDENTIFIER,
        critical BOOLEAN DEFAULT FALSE,
        extnValue OCTET STRING
    }
    Attributes
    ----------
    extnID : oid
    critical : boolean
    extnValue : octetstr
    """
    __slots__ = ["extnID", "critical", "extnValue"]

    def __init__(self):
        self.extnID = None
        self.critical = False
        self.extnValue = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("Extension tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode extnID

        elemlen = decctxt.match_elem_tag(bytearray([0x06]), 0)
        if elemlen is not None:
            self.extnID = decbuf.decode_oid()
        else:
            raise exc.Asn1MissingRequiredError("extnID")

        # decode critical

        elemlen = decctxt.match_elem_tag(bytearray([0x01]), 0)
        if elemlen is not None:
            self.critical = decbuf.decode_boolean()

        # decode extnValue

        elemlen = decctxt.match_elem_tag(bytearray([0x04]), 0)
        if elemlen is not None:
            self.extnValue = decbuf.decode_octetstr()
        else:
            raise exc.Asn1MissingRequiredError("extnValue")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode extnValue

        if self.extnValue is not None:
            len1 = encbuf.encode_octetstr(self.extnValue)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("extnValue")

        # encode critical

        if self.critical is not None:
            if not self.critical == False:
                len1 = encbuf.encode_boolean(self.critical)

                len0 += len1

        # encode extnID

        if self.extnID is not None:
            len1 = encbuf.encode_oid(self.extnID)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("extnID")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class Extensions:
    """Class definition for ASN.1 type:

    SEQUENCE (SIZE (1..MAX)) OF Extension
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("Extensions tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = Extension()
            value.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        for value in reversed(value_list):
            len1 = value.ber_encode(encbuf)
            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class TBSCertificate:
    """Class definition for ASN.1 type:

    SEQUENCE {
        version [0] Version DEFAULT v1,
        serialNumber CertificateSerialNumber,
        signature AlgorithmIdentifier,
        issuer Name,
        validity Validity,
        subject Name,
        subjectPublicKeyInfo SubjectPublicKeyInfo,
        issuerUniqueID [1] IMPLICIT UniqueIdentifier OPTIONAL,
                         -- If present, version MUST be v2 or v3
        subjectUniqueID [2] IMPLICIT UniqueIdentifier OPTIONAL,
                         -- If present, version MUST be v2 or v3
        extensions [3] Extensions OPTIONAL
    }
    Attributes
    ----------
    version : Version
    serialNumber : CertificateSerialNumber
    signature : AlgorithmIdentifier
    issuer : Name
    validity : Validity
    subject : Name
    subjectPublicKeyInfo : SubjectPublicKeyInfo
    issuerUniqueID : UniqueIdentifier
    subjectUniqueID : UniqueIdentifier
    extensions : Extensions
    """
    __slots__ = ["version", "serialNumber", "signature", "issuer", "validity", 
        "subject", "subjectPublicKeyInfo", "issuerUniqueID", "subjectUniqueID"
        , "extensions"]

    def __init__(self):
        self.version = "v1"
        self.serialNumber = None
        self.signature = None
        self.issuer = None
        self.validity = None
        self.subject = None
        self.subjectPublicKeyInfo = None
        self.issuerUniqueID = None
        self.subjectUniqueID = None
        self.extensions = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("TBSCertificate tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode version

        elemlen = decctxt.match_elem_tag(bytearray([0xa0]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.version = Version.ber_decode(decbuf)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode serialNumber

        elemlen = decctxt.match_elem_tag(bytearray([0x02]), 0)
        if elemlen is not None:
            self.serialNumber = decbuf.decode_integer()
        else:
            raise exc.Asn1MissingRequiredError("serialNumber")

        # decode signature

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.signature = AlgorithmIdentifier()
            self.signature.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("signature")

        # decode issuer

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.issuer = Name()
            self.issuer.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("issuer")

        # decode validity

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.validity = Validity()
            self.validity.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("validity")

        # decode subject

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.subject = Name()
            self.subject.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("subject")

        # decode subjectPublicKeyInfo

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.subjectPublicKeyInfo = SubjectPublicKeyInfo()
            self.subjectPublicKeyInfo.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("subjectPublicKeyInfo")

        # decode issuerUniqueID

        elemlen = decctxt.match_elem_tag(bytearray([0x81]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.issuerUniqueID = decbuf.decode_bitstr(False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode subjectUniqueID

        elemlen = decctxt.match_elem_tag(bytearray([0x82]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.subjectUniqueID = decbuf.decode_bitstr(False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode extensions

        elemlen = decctxt.match_elem_tag(bytearray([0xa3]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.extensions = Extensions.ber_decode(decbuf)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode extensions

        if self.extensions is not None:
            len1 = Extensions.ber_encode(self.extensions, encbuf)
            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytearray([0xa3]))

            len0 += len1

        # encode subjectUniqueID

        if self.subjectUniqueID is not None:
            tagbytes1 = bytearray([0x82])

            len1 = encbuf.encode_bitstr(self.subjectUniqueID, tagbytes1)

            len0 += len1

        # encode issuerUniqueID

        if self.issuerUniqueID is not None:
            tagbytes1 = bytearray([0x81])

            len1 = encbuf.encode_bitstr(self.issuerUniqueID, tagbytes1)

            len0 += len1

        # encode subjectPublicKeyInfo

        if self.subjectPublicKeyInfo is not None:
            len1 = self.subjectPublicKeyInfo.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("subjectPublicKeyInfo")

        # encode subject

        if self.subject is not None:
            len1 = self.subject.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("subject")

        # encode validity

        if self.validity is not None:
            len1 = self.validity.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("validity")

        # encode issuer

        if self.issuer is not None:
            len1 = self.issuer.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("issuer")

        # encode signature

        if self.signature is not None:
            len1 = self.signature.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("signature")

        # encode serialNumber

        if self.serialNumber is not None:
            len1 = encbuf.encode_integer(self.serialNumber)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("serialNumber")

        # encode version

        if self.version is not None:
            if not self.version == "v1":
                len1 = Version.ber_encode(self.version, encbuf)
                len1 += encbuf.encode_def_len(len1) + \
                    encbuf.encode_bytes(bytearray([0xa0]))

                len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class Certificate:
    """Class definition for ASN.1 type:

    SEQUENCE {
        tbsCertificate TBSCertificate,
        signatureAlgorithm AlgorithmIdentifier,
        signature BIT STRING 
    }
    Attributes
    ----------
    tbsCertificate : TBSCertificate
    signatureAlgorithm : AlgorithmIdentifier
    signature : bitstr
    """
    __slots__ = ["tbsCertificate", "signatureAlgorithm", "signature"]

    def __init__(self):
        self.tbsCertificate = None
        self.signatureAlgorithm = None
        self.signature = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("Certificate tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode tbsCertificate

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.tbsCertificate = TBSCertificate()
            self.tbsCertificate.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("tbsCertificate")

        # decode signatureAlgorithm

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.signatureAlgorithm = AlgorithmIdentifier()
            self.signatureAlgorithm.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("signatureAlgorithm")

        # decode signature

        elemlen = decctxt.match_elem_tag(bytearray([0x03]), 0)
        if elemlen is not None:
            self.signature = decbuf.decode_bitstr()
        else:
            raise exc.Asn1MissingRequiredError("signature")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode signature

        if self.signature is not None:
            len1 = encbuf.encode_bitstr(self.signature)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("signature")

        # encode signatureAlgorithm

        if self.signatureAlgorithm is not None:
            len1 = self.signatureAlgorithm.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("signatureAlgorithm")

        # encode tbsCertificate

        if self.tbsCertificate is not None:
            len1 = self.tbsCertificate.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("tbsCertificate")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class TBSCertList_revokedCertificates_element:
    """Class definition for ASN.1 type:

    SEQUENCE {
        userCertificate CertificateSerialNumber,
        revocationDate Time,
        crlEntryExtensions Extensions OPTIONAL
                                             -- if present, MUST be v2
    }
    Attributes
    ----------
    userCertificate : CertificateSerialNumber
    revocationDate : Time
    crlEntryExtensions : Extensions
    """
    __slots__ = ["userCertificate", "revocationDate", "crlEntryExtensions"]

    def __init__(self):
        self.userCertificate = None
        self.revocationDate = None
        self.crlEntryExtensions = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("SEQUENCE tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode userCertificate

        elemlen = decctxt.match_elem_tag(bytearray([0x02]), 0)
        if elemlen is not None:
            self.userCertificate = decbuf.decode_integer()
        else:
            raise exc.Asn1MissingRequiredError("userCertificate")

        # decode revocationDate

        elemlen = decctxt.match_elem_tag(bytearray([0x17]), 0)
        if elemlen is None:
            elemlen = decctxt.match_elem_tag(bytearray([0x18]), 0)
        if elemlen is not None:
            self.revocationDate = Time()
            self.revocationDate.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("revocationDate")

        # decode crlEntryExtensions

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.crlEntryExtensions = Extensions.ber_decode(decbuf)

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode crlEntryExtensions

        if self.crlEntryExtensions is not None:
            len1 = Extensions.ber_encode(self.crlEntryExtensions, encbuf)

            len0 += len1

        # encode revocationDate

        if self.revocationDate is not None:
            len1 = self.revocationDate.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("revocationDate")

        # encode userCertificate

        if self.userCertificate is not None:
            len1 = encbuf.encode_integer(self.userCertificate)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("userCertificate")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class TBSCertList:
    """Class definition for ASN.1 type:

    SEQUENCE {
        version Version OPTIONAL,
                                 -- if present, MUST be v2
        signature AlgorithmIdentifier,
        issuer Name,
        thisUpdate Time,
        nextUpdate Time OPTIONAL,
        revokedCertificates SEQUENCE OF SEQUENCE {
            userCertificate CertificateSerialNumber,
            revocationDate Time,
            crlEntryExtensions Extensions OPTIONAL
                                          -- if present, MUST be v2
        } OPTIONAL,
        crlExtensions [0] Extensions OPTIONAL
    }
    Attributes
    ----------
    version : Version
    signature : AlgorithmIdentifier
    issuer : Name
    thisUpdate : Time
    nextUpdate : Time
    revokedCertificates : list
    crlExtensions : Extensions
    """
    __slots__ = ["version", "signature", "issuer", "thisUpdate", "nextUpdate", 
        "revokedCertificates", "crlExtensions"]

    def __init__(self):
        self.version = None
        self.signature = None
        self.issuer = None
        self.thisUpdate = None
        self.nextUpdate = None
        self.revokedCertificates = None
        self.crlExtensions = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("TBSCertList tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode version

        elemlen = decctxt.match_elem_tag(bytearray([0x02]), 0)
        if elemlen is not None:
            self.version = Version.ber_decode(decbuf)

        # decode signature

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.signature = AlgorithmIdentifier()
            self.signature.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("signature")

        # decode issuer

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.issuer = Name()
            self.issuer.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("issuer")

        # decode thisUpdate

        elemlen = decctxt.match_elem_tag(bytearray([0x17]), 0)
        if elemlen is None:
            elemlen = decctxt.match_elem_tag(bytearray([0x18]), 0)
        if elemlen is not None:
            self.thisUpdate = Time()
            self.thisUpdate.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("thisUpdate")

        # decode nextUpdate

        elemlen = decctxt.match_elem_tag(bytearray([0x17]), 0)
        if elemlen is None:
            elemlen = decctxt.match_elem_tag(bytearray([0x18]), 0)
        if elemlen is not None:
            self.nextUpdate = Time()
            self.nextUpdate.ber_decode(decbuf)

        # decode revokedCertificates

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 1)
        if elemlen is not None:
            # decode SEQUENCE OF / SET OF

            self.revokedCertificates = []
            decctxt1 = ber.Asn1BerDecodeContext(decbuf, elemlen)

            while not decctxt1.expired():
                value = TBSCertList_revokedCertificates_element()
                value.ber_decode(decbuf)
                self.revokedCertificates.append(value)

        # decode crlExtensions

        elemlen = decctxt.match_elem_tag(bytearray([0xa0]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.crlExtensions = Extensions.ber_decode(decbuf)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode crlExtensions

        if self.crlExtensions is not None:
            len1 = Extensions.ber_encode(self.crlExtensions, encbuf)
            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytearray([0xa0]))

            len0 += len1

        # encode revokedCertificates

        if self.revokedCertificates is not None:
            len1 = 0
            for value in reversed(self.revokedCertificates):
                len2 = value.ber_encode(encbuf)
                len1 += len2

            tagbytes1 = bytearray([0x30])

            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(tagbytes1)

            len0 += len1

        # encode nextUpdate

        if self.nextUpdate is not None:
            len1 = self.nextUpdate.ber_encode(encbuf)

            len0 += len1

        # encode thisUpdate

        if self.thisUpdate is not None:
            len1 = self.thisUpdate.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("thisUpdate")

        # encode issuer

        if self.issuer is not None:
            len1 = self.issuer.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("issuer")

        # encode signature

        if self.signature is not None:
            len1 = self.signature.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("signature")

        # encode version

        if self.version is not None:
            len1 = Version.ber_encode(self.version, encbuf)

            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class CertificateList:
    """Class definition for ASN.1 type:

    SEQUENCE {
        tbsCertList TBSCertList,
        signatureAlgorithm AlgorithmIdentifier,
        signature BIT STRING 
    }
    Attributes
    ----------
    tbsCertList : TBSCertList
    signatureAlgorithm : AlgorithmIdentifier
    signature : bitstr
    """
    __slots__ = ["tbsCertList", "signatureAlgorithm", "signature"]

    def __init__(self):
        self.tbsCertList = None
        self.signatureAlgorithm = None
        self.signature = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("CertificateList tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode tbsCertList

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.tbsCertList = TBSCertList()
            self.tbsCertList.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("tbsCertList")

        # decode signatureAlgorithm

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.signatureAlgorithm = AlgorithmIdentifier()
            self.signatureAlgorithm.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("signatureAlgorithm")

        # decode signature

        elemlen = decctxt.match_elem_tag(bytearray([0x03]), 0)
        if elemlen is not None:
            self.signature = decbuf.decode_bitstr()
        else:
            raise exc.Asn1MissingRequiredError("signature")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode signature

        if self.signature is not None:
            len1 = encbuf.encode_bitstr(self.signature)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("signature")

        # encode signatureAlgorithm

        if self.signatureAlgorithm is not None:
            len1 = self.signatureAlgorithm.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("signatureAlgorithm")

        # encode tbsCertList

        if self.tbsCertList is not None:
            len1 = self.tbsCertList.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("tbsCertList")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class CountryName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    [APPLICATION 1] CHOICE {
        x121-dcc-code NumericString (SIZE (ub-country-name-numeric-length)),
        iso-3166-alpha2-code PrintableString (SIZE (ub-country-name-alpha-length))
    }
    Attributes
    ----------
    x121_dcc_code : charstr
    iso_3166_alpha2_code : charstr
    """
    __slots__ = ["x121_dcc_code", "iso_3166_alpha2_code"]

    def __init__(self):
        super().__init__()
        self.x121_dcc_code = None
        self.iso_3166_alpha2_code = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        # tag on CHOICE is always explicit

        if not decbuf.match_tag_bytes(bytearray([0x61])):
            raise exc.Asn1TagError("CountryName tag match failed")

        impllen = decbuf.decode_length()

        if decbuf.match_tag_bytes(bytearray([0x12]), False):
            # decode x121_dcc_code
            self.x121_dcc_code = decbuf.decode_charstr(18)
            if not len(self.x121_dcc_code) == 3:
                raise exc.Asn1ConsVioError("len(self.x121_dcc_code)", len(self.x121_dcc_code))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode iso_3166_alpha2_code
            self.iso_3166_alpha2_code = decbuf.decode_charstr(19)
            if not len(self.iso_3166_alpha2_code) == 2:
                raise exc.Asn1ConsVioError("len(self.iso_3166_alpha2_code)", len(self.iso_3166_alpha2_code))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "x121_dcc_code":
            if not len(self.x121_dcc_code) == 3:
                raise exc.Asn1ConsVioError("len(self.x121_dcc_code)", len(self.x121_dcc_code))

            len1 = encbuf.encode_charstr(self.x121_dcc_code, 18)
        elif attr == "iso_3166_alpha2_code":
            if not len(self.iso_3166_alpha2_code) == 2:
                raise exc.Asn1ConsVioError("len(self.iso_3166_alpha2_code)", len(self.iso_3166_alpha2_code))

            len1 = encbuf.encode_charstr(self.iso_3166_alpha2_code, 19)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1 + encbuf.encode_def_len(len1) + \
            encbuf.encode_bytes(bytearray([0x61]))

        return len0


class AdministrationDomainName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    [APPLICATION 2] CHOICE {
        numeric NumericString (SIZE (0..ub-domain-name-length)),
        printable PrintableString (SIZE (0..ub-domain-name-length))
    }
    Attributes
    ----------
    numeric : charstr
    printable : charstr
    """
    __slots__ = ["numeric", "printable"]

    def __init__(self):
        super().__init__()
        self.numeric = None
        self.printable = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        # tag on CHOICE is always explicit

        if not decbuf.match_tag_bytes(bytearray([0x62])):
            raise exc.Asn1TagError("AdministrationDomainName tag match failed")

        impllen = decbuf.decode_length()

        if decbuf.match_tag_bytes(bytearray([0x12]), False):
            # decode numeric
            self.numeric = decbuf.decode_charstr(18)
            if not (len(self.numeric) >= 0 and len(self.numeric) <= 16):
                raise exc.Asn1ConsVioError("len(self.numeric)", len(self.numeric))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printable
            self.printable = decbuf.decode_charstr(19)
            if not (len(self.printable) >= 0 and len(self.printable) <= 16):
                raise exc.Asn1ConsVioError("len(self.printable)", len(self.printable))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "numeric":
            if not (len(self.numeric) >= 0 and len(self.numeric) <= 16):
                raise exc.Asn1ConsVioError("len(self.numeric)", len(self.numeric))

            len1 = encbuf.encode_charstr(self.numeric, 18)
        elif attr == "printable":
            if not (len(self.printable) >= 0 and len(self.printable) <= 16):
                raise exc.Asn1ConsVioError("len(self.printable)", len(self.printable))

            len1 = encbuf.encode_charstr(self.printable, 19)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1 + encbuf.encode_def_len(len1) + \
            encbuf.encode_bytes(bytearray([0x62]))

        return len0


class PrivateDomainName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        numeric NumericString (SIZE (1..ub-domain-name-length)),
        printable PrintableString (SIZE (1..ub-domain-name-length))
    }
    Attributes
    ----------
    numeric : charstr
    printable : charstr
    """
    __slots__ = ["numeric", "printable"]

    def __init__(self):
        super().__init__()
        self.numeric = None
        self.printable = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x12]), False):
            # decode numeric
            self.numeric = decbuf.decode_charstr(18)
            if not (len(self.numeric) >= 1 and len(self.numeric) <= 16):
                raise exc.Asn1ConsVioError("len(self.numeric)", len(self.numeric))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printable
            self.printable = decbuf.decode_charstr(19)
            if not (len(self.printable) >= 1 and len(self.printable) <= 16):
                raise exc.Asn1ConsVioError("len(self.printable)", len(self.printable))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "numeric":
            if not (len(self.numeric) >= 1 and len(self.numeric) <= 16):
                raise exc.Asn1ConsVioError("len(self.numeric)", len(self.numeric))

            len1 = encbuf.encode_charstr(self.numeric, 18)
        elif attr == "printable":
            if not (len(self.printable) >= 1 and len(self.printable) <= 16):
                raise exc.Asn1ConsVioError("len(self.printable)", len(self.printable))

            len1 = encbuf.encode_charstr(self.printable, 19)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class PersonalName:
    """Class definition for ASN.1 type:

    SET {
        surname [0] IMPLICIT PrintableString (SIZE (1..ub-surname-length)),
        given-name [1] IMPLICIT PrintableString (SIZE (1..ub-given-name-length)) OPTIONAL,
        initials [2] IMPLICIT PrintableString (SIZE (1..ub-initials-length)) OPTIONAL,
        generation-qualifier [3] IMPLICIT PrintableString (SIZE (1..ub-generation-qualifier-length)) OPTIONAL
    }
    Attributes
    ----------
    surname : charstr
    given_name : charstr
    initials : charstr
    generation_qualifier : charstr
    """
    __slots__ = ["surname", "given_name", "initials", "generation_qualifier"]

    def __init__(self):
        self.surname = None
        self.given_name = None
        self.initials = None
        self.generation_qualifier = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x31])):
                raise exc.Asn1TagError("PersonalName tag match failed")

            impllen = decbuf.decode_length()

        # decode SET

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            # decode surname

            elemlen = decctxt.match_set_elem_tag(bytearray([0x80]), 1)
            if elemlen is not None:
                self.surname = decbuf.decode_charstr(19, False, elemlen)
                if not (len(self.surname) >= 1 and len(self.surname) <= 40):
                    raise exc.Asn1ConsVioError("len(self.surname)", len(self.surname))

                continue

            # decode given_name

            elemlen = decctxt.match_set_elem_tag(bytearray([0x81]), 1)
            if elemlen is not None:
                self.given_name = decbuf.decode_charstr(19, False, elemlen)
                if not (len(self.given_name) >= 1 and len(self.given_name) <= 16):
                    raise exc.Asn1ConsVioError("len(self.given_name)", len(self.given_name))

                continue

            # decode initials

            elemlen = decctxt.match_set_elem_tag(bytearray([0x82]), 1)
            if elemlen is not None:
                self.initials = decbuf.decode_charstr(19, False, elemlen)
                if not (len(self.initials) >= 1 and len(self.initials) <= 5):
                    raise exc.Asn1ConsVioError("len(self.initials)", len(self.initials))

                continue

            # decode generation_qualifier

            elemlen = decctxt.match_set_elem_tag(bytearray([0x83]), 1)
            if elemlen is not None:
                self.generation_qualifier = decbuf.decode_charstr(19, False, elemlen)
                if not (len(self.generation_qualifier) >= 1 and 
                    len(self.generation_qualifier) <= 3):
                    raise exc.Asn1ConsVioError("len(self.generation_qualifier)", len(self.generation_qualifier))

                continue

            raise exc.Asn1NotInSetError(decbuf.decode_tag())

        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is None and attr in ["surname"]:
                raise exc.Asn1MissingRequiredError(attr)

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode generation_qualifier

        if self.generation_qualifier is not None:
            tagbytes1 = bytearray([0x83])

            if not (len(self.generation_qualifier) >= 1 and 
                len(self.generation_qualifier) <= 3):
                raise exc.Asn1ConsVioError("len(self.generation_qualifier)", len(self.generation_qualifier))

            len1 = encbuf.encode_charstr(self.generation_qualifier, 19, tagbytes1)

            len0 += len1

        # encode initials

        if self.initials is not None:
            tagbytes1 = bytearray([0x82])

            if not (len(self.initials) >= 1 and len(self.initials) <= 5):
                raise exc.Asn1ConsVioError("len(self.initials)", len(self.initials))

            len1 = encbuf.encode_charstr(self.initials, 19, tagbytes1)

            len0 += len1

        # encode given_name

        if self.given_name is not None:
            tagbytes1 = bytearray([0x81])

            if not (len(self.given_name) >= 1 and len(self.given_name) <= 16):
                raise exc.Asn1ConsVioError("len(self.given_name)", len(self.given_name))

            len1 = encbuf.encode_charstr(self.given_name, 19, tagbytes1)

            len0 += len1

        # encode surname

        if self.surname is not None:
            tagbytes1 = bytearray([0x80])

            if not (len(self.surname) >= 1 and len(self.surname) <= 40):
                raise exc.Asn1ConsVioError("len(self.surname)", len(self.surname))

            len1 = encbuf.encode_charstr(self.surname, 19, tagbytes1)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("surname")

        if tagbytes is None:
            tagbytes = bytearray([0x31])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class OrganizationalUnitNames:
    """Class definition for ASN.1 type:

    SEQUENCE (SIZE (1..ub-organizational-units)) OF OrganizationalUnitName
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("OrganizationalUnitNames tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = OrganizationalUnitName.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        for value in reversed(value_list):
            len1 = OrganizationalUnitName.ber_encode(value, encbuf)
            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class BuiltInStandardAttributes:
    """Class definition for ASN.1 type:

    SEQUENCE {
        country-name CountryName OPTIONAL,
        administration-domain-name AdministrationDomainName OPTIONAL,
        network-address [0] IMPLICIT NetworkAddress OPTIONAL,
  -- see also extended-network-address
        terminal-identifier [1] IMPLICIT TerminalIdentifier OPTIONAL,
        private-domain-name [2] PrivateDomainName OPTIONAL,
        organization-name [3] IMPLICIT OrganizationName OPTIONAL,
  -- see also teletex-organization-name
        numeric-user-identifier [4] IMPLICIT NumericUserIdentifier OPTIONAL,
        personal-name [5] IMPLICIT PersonalName OPTIONAL,
  -- see also teletex-personal-name
        organizational-unit-names [6] IMPLICIT OrganizationalUnitNames OPTIONAL
    }
    Attributes
    ----------
    country_name : CountryName
    administration_domain_name : AdministrationDomainName
    network_address : NetworkAddress
    terminal_identifier : TerminalIdentifier
    private_domain_name : PrivateDomainName
    organization_name : OrganizationName
    numeric_user_identifier : NumericUserIdentifier
    personal_name : PersonalName
    organizational_unit_names : OrganizationalUnitNames
    """
    __slots__ = ["country_name", "administration_domain_name", 
        "network_address", "terminal_identifier", "private_domain_name", 
        "organization_name", "numeric_user_identifier", "personal_name", 
        "organizational_unit_names"]

    def __init__(self):
        self.country_name = None
        self.administration_domain_name = None
        self.network_address = None
        self.terminal_identifier = None
        self.private_domain_name = None
        self.organization_name = None
        self.numeric_user_identifier = None
        self.personal_name = None
        self.organizational_unit_names = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("BuiltInStandardAttributes tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode country_name

        elemlen = decctxt.match_elem_tag(bytearray([0x61]), 0)
        if elemlen is not None:
            self.country_name = CountryName()
            self.country_name.ber_decode(decbuf)

        # decode administration_domain_name

        elemlen = decctxt.match_elem_tag(bytearray([0x62]), 0)
        if elemlen is not None:
            self.administration_domain_name = AdministrationDomainName()
            self.administration_domain_name.ber_decode(decbuf)

        # decode network_address

        elemlen = decctxt.match_elem_tag(bytearray([0x80]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.network_address = X121Address.ber_decode(decbuf, False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode terminal_identifier

        elemlen = decctxt.match_elem_tag(bytearray([0x81]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.terminal_identifier = TerminalIdentifier.ber_decode(decbuf, False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode private_domain_name

        elemlen = decctxt.match_elem_tag(bytearray([0xa2]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.private_domain_name = PrivateDomainName()
            self.private_domain_name.ber_decode(decbuf)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode organization_name

        elemlen = decctxt.match_elem_tag(bytearray([0x83]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.organization_name = OrganizationName.ber_decode(decbuf, False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode numeric_user_identifier

        elemlen = decctxt.match_elem_tag(bytearray([0x84]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.numeric_user_identifier = NumericUserIdentifier.ber_decode(decbuf, False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode personal_name

        elemlen = decctxt.match_elem_tag(bytearray([0xa5]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.personal_name = PersonalName()
            self.personal_name.ber_decode(decbuf, False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode organizational_unit_names

        elemlen = decctxt.match_elem_tag(bytearray([0xa6]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.organizational_unit_names = OrganizationalUnitNames.ber_decode(decbuf, False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode organizational_unit_names

        if self.organizational_unit_names is not None:
            tagbytes1 = bytearray([0xa6])

            len1 = OrganizationalUnitNames.ber_encode(self.organizational_unit_names, encbuf, tagbytes1)

            len0 += len1

        # encode personal_name

        if self.personal_name is not None:
            tagbytes1 = bytearray([0xa5])

            len1 = self.personal_name.ber_encode(encbuf, tagbytes1)

            len0 += len1

        # encode numeric_user_identifier

        if self.numeric_user_identifier is not None:
            tagbytes1 = bytearray([0x84])

            len1 = NumericUserIdentifier.ber_encode(self.numeric_user_identifier, encbuf, tagbytes1)

            len0 += len1

        # encode organization_name

        if self.organization_name is not None:
            tagbytes1 = bytearray([0x83])

            len1 = OrganizationName.ber_encode(self.organization_name, encbuf, tagbytes1)

            len0 += len1

        # encode private_domain_name

        if self.private_domain_name is not None:
            len1 = self.private_domain_name.ber_encode(encbuf)
            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytearray([0xa2]))

            len0 += len1

        # encode terminal_identifier

        if self.terminal_identifier is not None:
            tagbytes1 = bytearray([0x81])

            len1 = TerminalIdentifier.ber_encode(self.terminal_identifier, encbuf, tagbytes1)

            len0 += len1

        # encode network_address

        if self.network_address is not None:
            tagbytes1 = bytearray([0x80])

            len1 = X121Address.ber_encode(self.network_address, encbuf, tagbytes1)

            len0 += len1

        # encode administration_domain_name

        if self.administration_domain_name is not None:
            len1 = self.administration_domain_name.ber_encode(encbuf)

            len0 += len1

        # encode country_name

        if self.country_name is not None:
            len1 = self.country_name.ber_encode(encbuf)

            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class BuiltInDomainDefinedAttribute:
    """Class definition for ASN.1 type:

    SEQUENCE {
        type PrintableString (SIZE (1..ub-domain-defined-attribute-type-length)),
        value PrintableString (SIZE (1..ub-domain-defined-attribute-value-length))
    }
    Attributes
    ----------
    type : charstr
    value : charstr
    """
    __slots__ = ["type", "value"]

    def __init__(self):
        self.type = None
        self.value = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("BuiltInDomainDefinedAttribute tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode type

        elemlen = decctxt.match_elem_tag(bytearray([0x13]), 0)
        if elemlen is not None:
            self.type = decbuf.decode_charstr(19)
            if not (len(self.type) >= 1 and len(self.type) <= 8):
                raise exc.Asn1ConsVioError("len(self.type)", len(self.type))

        else:
            raise exc.Asn1MissingRequiredError("type")

        # decode value

        elemlen = decctxt.match_elem_tag(bytearray([0x13]), 0)
        if elemlen is not None:
            self.value = decbuf.decode_charstr(19)
            if not (len(self.value) >= 1 and len(self.value) <= 128):
                raise exc.Asn1ConsVioError("len(self.value)", len(self.value))

        else:
            raise exc.Asn1MissingRequiredError("value")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode value

        if self.value is not None:
            if not (len(self.value) >= 1 and len(self.value) <= 128):
                raise exc.Asn1ConsVioError("len(self.value)", len(self.value))

            len1 = encbuf.encode_charstr(self.value, 19)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("value")

        # encode type

        if self.type is not None:
            if not (len(self.type) >= 1 and len(self.type) <= 8):
                raise exc.Asn1ConsVioError("len(self.type)", len(self.type))

            len1 = encbuf.encode_charstr(self.type, 19)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("type")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class BuiltInDomainDefinedAttributes:
    """Class definition for ASN.1 type:

    SEQUENCE (SIZE (1..ub-domain-defined-attributes)) OF BuiltInDomainDefinedAttribute
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("BuiltInDomainDefinedAttributes tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = BuiltInDomainDefinedAttribute()
            value.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        for value in reversed(value_list):
            len1 = value.ber_encode(encbuf)
            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class ExtensionAttribute:
    """Class definition for ASN.1 type:

    SEQUENCE {
        extension-attribute-type [0] IMPLICIT INTEGER (0..ub-extension-attributes),
        extension-attribute-value [1] ANY
    }
    Attributes
    ----------
    extension_attribute_type : integer
    extension_attribute_value : opentype
    """
    __slots__ = ["extension_attribute_type", "extension_attribute_value"]

    def __init__(self):
        self.extension_attribute_type = None
        self.extension_attribute_value = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("ExtensionAttribute tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode extension_attribute_type

        elemlen = decctxt.match_elem_tag(bytearray([0x80]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.extension_attribute_type = decbuf.decode_integer(False, elemlen)
            if not (self.extension_attribute_type >= 0 and 
                self.extension_attribute_type <= 256):
                raise exc.Asn1ConsVioError("self.extension_attribute_type", self.extension_attribute_type)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        else:
            raise exc.Asn1MissingRequiredError("extension_attribute_type")

        # decode extension_attribute_value

        elemlen = decctxt.match_elem_tag(bytearray([0xa1]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.extension_attribute_value = decbuf.decode_opentype()

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        else:
            raise exc.Asn1MissingRequiredError("extension_attribute_value")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode extension_attribute_value

        if self.extension_attribute_value is not None:
            len1 = encbuf.encode_opentype(self.extension_attribute_value)
            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytearray([0xa1]))

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("extension_attribute_value")

        # encode extension_attribute_type

        if self.extension_attribute_type is not None:
            tagbytes1 = bytearray([0x80])

            if not (self.extension_attribute_type >= 0 and 
                self.extension_attribute_type <= 256):
                raise exc.Asn1ConsVioError("self.extension_attribute_type", self.extension_attribute_type)

            len1 = encbuf.encode_integer(self.extension_attribute_type, tagbytes1)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("extension_attribute_type")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class ExtensionAttributes:
    """Class definition for ASN.1 type:

    SET (SIZE (1..ub-extension-attributes)) OF ExtensionAttribute
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x31])):
                raise exc.Asn1TagError("ExtensionAttributes tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = ExtensionAttribute()
            value.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        saved_encbuf = encbuf
        encbuf = ber.Asn1BerEncodeBuffer()
        encoded_elems = []
        for value in reversed(value_list):
            len1 = value.ber_encode(encbuf)
            len0 += len1
            encoded_elems.append(encbuf.buffer())
            encbuf = ber.Asn1BerEncodeBuffer()

        encbuf = saved_encbuf
        encoded_elems.sort()

        for encbytes in reversed(encoded_elems):
            encbuf.encode_bytes(encbytes)

        if tagbytes is None:
            tagbytes = bytearray([0x31])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class ORAddress:
    """Class definition for ASN.1 type:

    SEQUENCE {
        built-in-standard-attributes BuiltInStandardAttributes,
        built-in-domain-defined-attributes BuiltInDomainDefinedAttributes OPTIONAL,
-- see also teletex-domain-defined-attributes
        extension-attributes ExtensionAttributes OPTIONAL
    }
    Attributes
    ----------
    built_in_standard_attributes : BuiltInStandardAttributes
    built_in_domain_defined_attributes : BuiltInDomainDefinedAttributes
    extension_attributes : ExtensionAttributes
    """
    __slots__ = ["built_in_standard_attributes", 
        "built_in_domain_defined_attributes", "extension_attributes"]

    def __init__(self):
        self.built_in_standard_attributes = None
        self.built_in_domain_defined_attributes = None
        self.extension_attributes = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("ORAddress tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode built_in_standard_attributes

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.built_in_standard_attributes = BuiltInStandardAttributes()
            self.built_in_standard_attributes.ber_decode(decbuf)
        else:
            raise exc.Asn1MissingRequiredError("built_in_standard_attributes")

        # decode built_in_domain_defined_attributes

        elemlen = decctxt.match_elem_tag(bytearray([0x30]), 0)
        if elemlen is not None:
            self.built_in_domain_defined_attributes = BuiltInDomainDefinedAttributes.ber_decode(decbuf)

        # decode extension_attributes

        elemlen = decctxt.match_elem_tag(bytearray([0x31]), 0)
        if elemlen is not None:
            self.extension_attributes = ExtensionAttributes.ber_decode(decbuf)

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode extension_attributes

        if self.extension_attributes is not None:
            len1 = ExtensionAttributes.ber_encode(self.extension_attributes, encbuf)

            len0 += len1

        # encode built_in_domain_defined_attributes

        if self.built_in_domain_defined_attributes is not None:
            len1 = BuiltInDomainDefinedAttributes.ber_encode(self.built_in_domain_defined_attributes, encbuf)

            len0 += len1

        # encode built_in_standard_attributes

        if self.built_in_standard_attributes is not None:
            len1 = self.built_in_standard_attributes.ber_encode(encbuf)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("built_in_standard_attributes")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class TeletexPersonalName:
    """Class definition for ASN.1 type:

    SET {
        surname [0] IMPLICIT T61String (SIZE (1..ub-surname-length)),
        given-name [1] IMPLICIT T61String (SIZE (1..ub-given-name-length)) OPTIONAL,
        initials [2] IMPLICIT T61String (SIZE (1..ub-initials-length)) OPTIONAL,
        generation-qualifier [3] IMPLICIT T61String (SIZE (1..ub-generation-qualifier-length)) OPTIONAL
    }
    Attributes
    ----------
    surname : charstr
    given_name : charstr
    initials : charstr
    generation_qualifier : charstr
    """
    __slots__ = ["surname", "given_name", "initials", "generation_qualifier"]

    def __init__(self):
        self.surname = None
        self.given_name = None
        self.initials = None
        self.generation_qualifier = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x31])):
                raise exc.Asn1TagError("TeletexPersonalName tag match failed")

            impllen = decbuf.decode_length()

        # decode SET

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            # decode surname

            elemlen = decctxt.match_set_elem_tag(bytearray([0x80]), 1)
            if elemlen is not None:
                self.surname = decbuf.decode_charstr(20, False, elemlen)
                if not (len(self.surname) >= 1 and len(self.surname) <= 40):
                    raise exc.Asn1ConsVioError("len(self.surname)", len(self.surname))

                continue

            # decode given_name

            elemlen = decctxt.match_set_elem_tag(bytearray([0x81]), 1)
            if elemlen is not None:
                self.given_name = decbuf.decode_charstr(20, False, elemlen)
                if not (len(self.given_name) >= 1 and len(self.given_name) <= 16):
                    raise exc.Asn1ConsVioError("len(self.given_name)", len(self.given_name))

                continue

            # decode initials

            elemlen = decctxt.match_set_elem_tag(bytearray([0x82]), 1)
            if elemlen is not None:
                self.initials = decbuf.decode_charstr(20, False, elemlen)
                if not (len(self.initials) >= 1 and len(self.initials) <= 5):
                    raise exc.Asn1ConsVioError("len(self.initials)", len(self.initials))

                continue

            # decode generation_qualifier

            elemlen = decctxt.match_set_elem_tag(bytearray([0x83]), 1)
            if elemlen is not None:
                self.generation_qualifier = decbuf.decode_charstr(20, False, elemlen)
                if not (len(self.generation_qualifier) >= 1 and 
                    len(self.generation_qualifier) <= 3):
                    raise exc.Asn1ConsVioError("len(self.generation_qualifier)", len(self.generation_qualifier))

                continue

            raise exc.Asn1NotInSetError(decbuf.decode_tag())

        for attr in self.__slots__:
            value = getattr(self, attr)
            if value is None and attr in ["surname"]:
                raise exc.Asn1MissingRequiredError(attr)

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode generation_qualifier

        if self.generation_qualifier is not None:
            tagbytes1 = bytearray([0x83])

            if not (len(self.generation_qualifier) >= 1 and 
                len(self.generation_qualifier) <= 3):
                raise exc.Asn1ConsVioError("len(self.generation_qualifier)", len(self.generation_qualifier))

            len1 = encbuf.encode_charstr(self.generation_qualifier, 20, tagbytes1)

            len0 += len1

        # encode initials

        if self.initials is not None:
            tagbytes1 = bytearray([0x82])

            if not (len(self.initials) >= 1 and len(self.initials) <= 5):
                raise exc.Asn1ConsVioError("len(self.initials)", len(self.initials))

            len1 = encbuf.encode_charstr(self.initials, 20, tagbytes1)

            len0 += len1

        # encode given_name

        if self.given_name is not None:
            tagbytes1 = bytearray([0x81])

            if not (len(self.given_name) >= 1 and len(self.given_name) <= 16):
                raise exc.Asn1ConsVioError("len(self.given_name)", len(self.given_name))

            len1 = encbuf.encode_charstr(self.given_name, 20, tagbytes1)

            len0 += len1

        # encode surname

        if self.surname is not None:
            tagbytes1 = bytearray([0x80])

            if not (len(self.surname) >= 1 and len(self.surname) <= 40):
                raise exc.Asn1ConsVioError("len(self.surname)", len(self.surname))

            len1 = encbuf.encode_charstr(self.surname, 20, tagbytes1)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("surname")

        if tagbytes is None:
            tagbytes = bytearray([0x31])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class TeletexOrganizationalUnitNames:
    """Class definition for ASN.1 type:

    SEQUENCE (SIZE (1..ub-organizational-units)) OF TeletexOrganizationalUnitName
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("TeletexOrganizationalUnitNames tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = TeletexOrganizationalUnitName.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        for value in reversed(value_list):
            len1 = TeletexOrganizationalUnitName.ber_encode(value, encbuf)
            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class PhysicalDeliveryCountryName(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        x121-dcc-code NumericString (SIZE (ub-country-name-numeric-length)),
        iso-3166-alpha2-code PrintableString (SIZE (ub-country-name-alpha-length))
    }
    Attributes
    ----------
    x121_dcc_code : charstr
    iso_3166_alpha2_code : charstr
    """
    __slots__ = ["x121_dcc_code", "iso_3166_alpha2_code"]

    def __init__(self):
        super().__init__()
        self.x121_dcc_code = None
        self.iso_3166_alpha2_code = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x12]), False):
            # decode x121_dcc_code
            self.x121_dcc_code = decbuf.decode_charstr(18)
            if not len(self.x121_dcc_code) == 3:
                raise exc.Asn1ConsVioError("len(self.x121_dcc_code)", len(self.x121_dcc_code))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode iso_3166_alpha2_code
            self.iso_3166_alpha2_code = decbuf.decode_charstr(19)
            if not len(self.iso_3166_alpha2_code) == 2:
                raise exc.Asn1ConsVioError("len(self.iso_3166_alpha2_code)", len(self.iso_3166_alpha2_code))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "x121_dcc_code":
            if not len(self.x121_dcc_code) == 3:
                raise exc.Asn1ConsVioError("len(self.x121_dcc_code)", len(self.x121_dcc_code))

            len1 = encbuf.encode_charstr(self.x121_dcc_code, 18)
        elif attr == "iso_3166_alpha2_code":
            if not len(self.iso_3166_alpha2_code) == 2:
                raise exc.Asn1ConsVioError("len(self.iso_3166_alpha2_code)", len(self.iso_3166_alpha2_code))

            len1 = encbuf.encode_charstr(self.iso_3166_alpha2_code, 19)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class PostalCode(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        numeric-code NumericString (SIZE (1..ub-postal-code-length)),
        printable-code PrintableString (SIZE (1..ub-postal-code-length))
    }
    Attributes
    ----------
    numeric_code : charstr
    printable_code : charstr
    """
    __slots__ = ["numeric_code", "printable_code"]

    def __init__(self):
        super().__init__()
        self.numeric_code = None
        self.printable_code = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x12]), False):
            # decode numeric_code
            self.numeric_code = decbuf.decode_charstr(18)
            if not (len(self.numeric_code) >= 1 and len(self.numeric_code) <= 16):
                raise exc.Asn1ConsVioError("len(self.numeric_code)", len(self.numeric_code))

        elif decbuf.match_tag_bytes(bytearray([0x13]), False):
            # decode printable_code
            self.printable_code = decbuf.decode_charstr(19)
            if not (len(self.printable_code) >= 1 and len(self.printable_code) <= 16):
                raise exc.Asn1ConsVioError("len(self.printable_code)", len(self.printable_code))

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "numeric_code":
            if not (len(self.numeric_code) >= 1 and len(self.numeric_code) <= 16):
                raise exc.Asn1ConsVioError("len(self.numeric_code)", len(self.numeric_code))

            len1 = encbuf.encode_charstr(self.numeric_code, 18)
        elif attr == "printable_code":
            if not (len(self.printable_code) >= 1 and len(self.printable_code) <= 16):
                raise exc.Asn1ConsVioError("len(self.printable_code)", len(self.printable_code))

            len1 = encbuf.encode_charstr(self.printable_code, 19)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class UnformattedPostalAddress:
    """Class definition for ASN.1 type:

    SET {
        printable-address SEQUENCE (SIZE (1..ub-pds-physical-address-lines)) OF PrintableString (SIZE (1..ub-pds-parameter-length)) OPTIONAL,
        teletex-string T61String (SIZE (1..ub-unformatted-address-length)) OPTIONAL
    }
    Attributes
    ----------
    printable_address : list
    teletex_string : charstr
    """
    __slots__ = ["printable_address", "teletex_string"]

    def __init__(self):
        self.printable_address = None
        self.teletex_string = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x31])):
                raise exc.Asn1TagError("UnformattedPostalAddress tag match failed")

            impllen = decbuf.decode_length()

        # decode SET

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            # decode printable_address

            elemlen = decctxt.match_set_elem_tag(bytearray([0x30]), 1)
            if elemlen is not None:
                # decode SEQUENCE OF / SET OF

                self.printable_address = []
                decctxt1 = ber.Asn1BerDecodeContext(decbuf, elemlen)

                while not decctxt1.expired():
                    value = decbuf.decode_charstr(19)
                    if not (len(value) >= 1 and len(value) <= 30):
                        raise exc.Asn1ConsVioError("len(value)", len(value))

                    self.printable_address.append(value)

                continue

            # decode teletex_string

            elemlen = decctxt.match_set_elem_tag(bytearray([0x14]), 0)
            if elemlen is not None:
                self.teletex_string = decbuf.decode_charstr(20)
                if not (len(self.teletex_string) >= 1 and len(self.teletex_string)
                     <= 180):
                    raise exc.Asn1ConsVioError("len(self.teletex_string)", len(self.teletex_string))

                continue

            raise exc.Asn1NotInSetError(decbuf.decode_tag())

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode teletex_string

        if self.teletex_string is not None:
            if not (len(self.teletex_string) >= 1 and len(self.teletex_string) <= 180):
                raise exc.Asn1ConsVioError("len(self.teletex_string)", len(self.teletex_string))

            len1 = encbuf.encode_charstr(self.teletex_string, 20)

            len0 += len1

        # encode printable_address

        if self.printable_address is not None:
            len1 = 0
            for value in reversed(self.printable_address):
                if not (len(value) >= 1 and len(value) <= 30):
                    raise exc.Asn1ConsVioError("len(value)", len(value))

                len2 = encbuf.encode_charstr(value, 19)
                len1 += len2

            tagbytes1 = bytearray([0x30])

            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(tagbytes1)

            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x31])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class ExtendedNetworkAddress_e163_4_address:
    """Class definition for ASN.1 type:

    SEQUENCE {
        number [0] IMPLICIT NumericString (SIZE (1..ub-e163-4-number-length)),
        sub-address [1] IMPLICIT NumericString (SIZE (1..ub-e163-4-sub-address-length)) OPTIONAL
    }
    Attributes
    ----------
    number : charstr
    sub_address : charstr
    """
    __slots__ = ["number", "sub_address"]

    def __init__(self):
        self.number = None
        self.sub_address = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("SEQUENCE tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode number

        elemlen = decctxt.match_elem_tag(bytearray([0x80]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.number = decbuf.decode_charstr(18, False, elemlen)
            if not (len(self.number) >= 1 and len(self.number) <= 15):
                raise exc.Asn1ConsVioError("len(self.number)", len(self.number))

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        else:
            raise exc.Asn1MissingRequiredError("number")

        # decode sub_address

        elemlen = decctxt.match_elem_tag(bytearray([0x81]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.sub_address = decbuf.decode_charstr(18, False, elemlen)
            if not (len(self.sub_address) >= 1 and len(self.sub_address) <= 40):
                raise exc.Asn1ConsVioError("len(self.sub_address)", len(self.sub_address))

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode sub_address

        if self.sub_address is not None:
            tagbytes1 = bytearray([0x81])

            if not (len(self.sub_address) >= 1 and len(self.sub_address) <= 40):
                raise exc.Asn1ConsVioError("len(self.sub_address)", len(self.sub_address))

            len1 = encbuf.encode_charstr(self.sub_address, 18, tagbytes1)

            len0 += len1

        # encode number

        if self.number is not None:
            tagbytes1 = bytearray([0x80])

            if not (len(self.number) >= 1 and len(self.number) <= 15):
                raise exc.Asn1ConsVioError("len(self.number)", len(self.number))

            len1 = encbuf.encode_charstr(self.number, 18, tagbytes1)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("number")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class PresentationAddress:
    """Class definition for ASN.1 type:

    SEQUENCE {
        pSelector [0] OCTET STRING OPTIONAL,
        sSelector [1] OCTET STRING OPTIONAL,
        tSelector [2] OCTET STRING OPTIONAL,
        nAddresses [3] SET (SIZE (1..MAX)) OF OCTET STRING
    }
    Attributes
    ----------
    pSelector : octetstr
    sSelector : octetstr
    tSelector : octetstr
    nAddresses : list
    """
    __slots__ = ["pSelector", "sSelector", "tSelector", "nAddresses"]

    def __init__(self):
        self.pSelector = None
        self.sSelector = None
        self.tSelector = None
        self.nAddresses = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("PresentationAddress tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode pSelector

        elemlen = decctxt.match_elem_tag(bytearray([0xa0]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.pSelector = decbuf.decode_octetstr()

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode sSelector

        elemlen = decctxt.match_elem_tag(bytearray([0xa1]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.sSelector = decbuf.decode_octetstr()

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode tSelector

        elemlen = decctxt.match_elem_tag(bytearray([0xa2]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            self.tSelector = decbuf.decode_octetstr()

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        # decode nAddresses

        elemlen = decctxt.match_elem_tag(bytearray([0xa3]), 1)
        if elemlen is not None:
            offset = decbuf.byte_count
            if not decbuf.match_tag_byte(0x31):
                raise exc.Asn1TagError("SEQUENCE or SET OF tag match failed")

            llen2 = elemlen;
            elemlen = decbuf.decode_length()

            # decode SEQUENCE OF / SET OF

            self.nAddresses = []
            decctxt1 = ber.Asn1BerDecodeContext(decbuf, elemlen)

            while not decctxt1.expired():
                value = decbuf.decode_octetstr()
                self.nAddresses.append(value)

            if elemlen.indef:
                decbuf.match_eoc()

            elemlen = llen2

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()

        else:
            raise exc.Asn1MissingRequiredError("nAddresses")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode nAddresses

        if self.nAddresses is not None:
            saved_encbuf = encbuf
            encbuf = ber.Asn1BerEncodeBuffer()
            encoded_elems = []
            len1 = 0
            for value in reversed(self.nAddresses):
                len2 = encbuf.encode_octetstr(value)
                len1 += len2
                encoded_elems.append(encbuf.buffer())
                encbuf = ber.Asn1BerEncodeBuffer()

            encbuf = saved_encbuf
            encoded_elems.sort()

            for encbytes in reversed(encoded_elems):
                encbuf.encode_bytes(encbytes)

            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytes([0x31]))

            tagbytes1 = bytearray([0xa3])

            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(tagbytes1)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("nAddresses")

        # encode tSelector

        if self.tSelector is not None:
            len1 = encbuf.encode_octetstr(self.tSelector)
            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytearray([0xa2]))

            len0 += len1

        # encode sSelector

        if self.sSelector is not None:
            len1 = encbuf.encode_octetstr(self.sSelector)
            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytearray([0xa1]))

            len0 += len1

        # encode pSelector

        if self.pSelector is not None:
            len1 = encbuf.encode_octetstr(self.pSelector)
            len1 += encbuf.encode_def_len(len1) + \
                encbuf.encode_bytes(bytearray([0xa0]))

            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class ExtendedNetworkAddress(univ.Asn1Choice):
    """Class definition for ASN.1 type:

    CHOICE {
        e163-4-address SEQUENCE {
            number [0] IMPLICIT NumericString (SIZE (1..ub-e163-4-number-length)),
            sub-address [1] IMPLICIT NumericString (SIZE (1..ub-e163-4-sub-address-length)) OPTIONAL
        },
        psap-address [0] IMPLICIT PresentationAddress
    }
    Attributes
    ----------
    e163_4_address : ExtendedNetworkAddress_e163_4_address
    psap_address : PresentationAddress
    """
    __slots__ = ["e163_4_address", "psap_address"]

    def __init__(self):
        super().__init__()
        self.e163_4_address = None
        self.psap_address = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if decbuf.match_tag_bytes(bytearray([0x30]), False):
            # decode e163_4_address
            self.e163_4_address = ExtendedNetworkAddress_e163_4_address()
            self.e163_4_address.ber_decode(decbuf)
        elif decbuf.match_tag_bytes(bytearray([0xa0])):
            # decode psap_address
            elemlen = decbuf.decode_length()
            offset = decbuf.byte_count
            self.psap_address = PresentationAddress()
            self.psap_address.ber_decode(decbuf, False, elemlen)

            if not elemlen.indef:
                declen = decbuf.byte_count - offset
                if declen != elemlen.value:
                    raise exc.Asn1LengthError()
            else:
                decbuf.match_eoc()

        else:
            raise exc.Asn1InvalidChoiceOptionError

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0
        attr = self.which()

        if attr == "e163_4_address":
            len1 = self.e163_4_address.ber_encode(encbuf)
        elif attr == "psap_address":
            tagbytes1 = bytearray([0xa0])

            len1 = self.psap_address.ber_encode(encbuf, tagbytes1)
        else:
            raise exc.Asn1InvalidChoiceOptionError

        len0 += len1
        return len0


class TeletexDomainDefinedAttribute:
    """Class definition for ASN.1 type:

    SEQUENCE {
        type T61String (SIZE (1..ub-domain-defined-attribute-type-length)),
        value T61String (SIZE (1..ub-domain-defined-attribute-value-length))
    }
    Attributes
    ----------
    type : charstr
    value : charstr
    """
    __slots__ = ["type", "value"]

    def __init__(self):
        self.type = None
        self.value = None

    def ber_decode(self, decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("TeletexDomainDefinedAttribute tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE

        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        # decode type

        elemlen = decctxt.match_elem_tag(bytearray([0x14]), 0)
        if elemlen is not None:
            self.type = decbuf.decode_charstr(20)
            if not (len(self.type) >= 1 and len(self.type) <= 8):
                raise exc.Asn1ConsVioError("len(self.type)", len(self.type))

        else:
            raise exc.Asn1MissingRequiredError("type")

        # decode value

        elemlen = decctxt.match_elem_tag(bytearray([0x14]), 0)
        if elemlen is not None:
            self.value = decbuf.decode_charstr(20)
            if not (len(self.value) >= 1 and len(self.value) <= 128):
                raise exc.Asn1ConsVioError("len(self.value)", len(self.value))

        else:
            raise exc.Asn1MissingRequiredError("value")

        if not decctxt.expired():
            raise exc.Asn1SeqOrderError()

    def ber_encode(self, encbuf, tagbytes=None):
        len0 = 0

        # encode value

        if self.value is not None:
            if not (len(self.value) >= 1 and len(self.value) <= 128):
                raise exc.Asn1ConsVioError("len(self.value)", len(self.value))

            len1 = encbuf.encode_charstr(self.value, 20)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("value")

        # encode type

        if self.type is not None:
            if not (len(self.type) >= 1 and len(self.type) <= 8):
                raise exc.Asn1ConsVioError("len(self.type)", len(self.type))

            len1 = encbuf.encode_charstr(self.type, 20)

            len0 += len1
        else:
            raise exc.Asn1MissingRequiredError("type")

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0


class TeletexDomainDefinedAttributes:
    """Class definition for ASN.1 type:

    SEQUENCE (SIZE (1..ub-domain-defined-attributes)) OF TeletexDomainDefinedAttribute
    """

    @staticmethod
    def ber_decode(decbuf, explicit=True, impllen=None):
        if explicit:
            if not decbuf.match_tag_bytes(bytearray([0x30])):
                raise exc.Asn1TagError("TeletexDomainDefinedAttributes tag match failed")

            impllen = decbuf.decode_length()

        # decode SEQUENCE OF / SET OF

        value_list = []
        decctxt = ber.Asn1BerDecodeContext(decbuf, impllen)

        while not decctxt.expired():
            value = TeletexDomainDefinedAttribute()
            value.ber_decode(decbuf)
            value_list.append(value)

        return value_list

    @staticmethod
    def ber_encode(value_list, encbuf, tagbytes=None):
        # encode SEQUENCE OF or SET OF

        len0 = 0
        for value in reversed(value_list):
            len1 = value.ber_encode(encbuf)
            len0 += len1

        if tagbytes is None:
            tagbytes = bytearray([0x30])

        len0 += encbuf.encode_def_len(len0) + \
            encbuf.encode_bytes(tagbytes)

        return len0

